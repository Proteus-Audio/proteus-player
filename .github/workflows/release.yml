name: Release

on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  contents: write

env:
  RELEASE_TAG_PREFIX: proteus-player-v

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      release_body: ${{ steps.build_notes.outputs.release_body }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read Cargo package version
        id: version
        run: |
          VERSION="$(awk -F'"' '/^\[package\]/{in_package=1;next} in_package && /^version = /{print $2; exit}' Cargo.toml)"
          if [ -z "$VERSION" ]; then
            echo "Could not determine package version from Cargo.toml" >&2
            exit 1
          fi
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"

      - name: Generate release notes
        id: git_cliff
        uses: orhun/git-cliff-action@v4
        with:
          config: cliff.toml
          args: --unreleased --tag "${{ env.RELEASE_TAG_PREFIX }}${{ steps.version.outputs.version }}"
        env:
          OUTPUT: release-notes.md
          GITHUB_REPO: ${{ github.repository }}

      - name: Build release notes
        id: build_notes
        run: |
          if [ ! -s release-notes.md ]; then
            echo "No notable changes in this release." > release-notes.md
          fi

          DELIM="RELEASE_BODY_$(date +%s)_$RANDOM"
          {
            echo "release_body<<${DELIM}"
            cat release-notes.md
            echo "${DELIM}"
          } >> "$GITHUB_OUTPUT"

  create-release:
    needs: prepare-release
    runs-on: ubuntu-latest
    steps:
      - name: Create or update release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          VERSION: ${{ needs.prepare-release.outputs.version }}
          RELEASE_BODY: ${{ needs.prepare-release.outputs.release_body }}
        run: |
          TAG="${RELEASE_TAG_PREFIX}${VERSION}"
          TITLE="Proteus Player v${VERSION}"

          if gh release view "${TAG}" >/dev/null 2>&1; then
            gh release edit "${TAG}" --title "${TITLE}" --notes "${RELEASE_BODY}"
          else
            gh release create "${TAG}" --title "${TITLE}" --notes "${RELEASE_BODY}"
          fi

  publish-iced:
    needs: [prepare-release, create-release]
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-14
            target: aarch64-apple-darwin
            kind: macos
            formats: app,dmg
          - platform: macos-15-intel
            target: x86_64-apple-darwin
            kind: macos
            formats: app,dmg
          - platform: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            kind: linux
            formats: deb,appimage,pacman
          - platform: ubuntu-24.04-arm
            target: aarch64-unknown-linux-gnu
            kind: linux
            formats: deb,appimage,pacman
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            kind: windows
            formats: nsis,wix
          - platform: windows-11-arm
            target: aarch64-pc-windows-msvc
            kind: windows
            formats: nsis

    runs-on: ${{ matrix.platform }}

    steps:
      - uses: actions/checkout@v4

      - name: Disable before-packaging hook in CI (macOS/Linux)
        if: matrix.kind != 'windows'
        run: sed -i.bak '/^before-packaging-command = "cargo build --release"$/d' Cargo.toml

      - name: Disable before-packaging hook in CI (Windows)
        if: matrix.kind == 'windows'
        shell: pwsh
        run: |
          $content = Get-Content Cargo.toml -Raw
          $updated = $content -replace '(?m)^before-packaging-command = "cargo build --release"\r?\n', ''
          Set-Content Cargo.toml -Value $updated -NoNewline

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install Linux system dependencies
        if: matrix.kind == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            pkg-config \
            libglib2.0-dev \
            libatk1.0-dev \
            libgtk-3-dev \
            libasound2-dev \
            libxdo-dev \
            fakeroot \
            dpkg-dev \
            rpm \
            patchelf
          sudo apt-get install -y libfuse2 || sudo apt-get install -y libfuse2t64

      - name: Install Windows packaging tools
        if: matrix.kind == 'windows'
        shell: pwsh
        run: choco install wixtoolset nsis -y

      - name: Install cargo-binstall
        uses: cargo-bins/cargo-binstall@main

      - name: Install cargo-packager
        run: cargo binstall --no-confirm cargo-packager

      - name: Build binary for target (macOS/Linux)
        if: matrix.kind != 'windows'
        env:
          TARGET: ${{ matrix.target }}
        run: cargo build --release --target "$TARGET"

      - name: Build and package (macOS/Linux)
        if: matrix.kind != 'windows'
        env:
          TARGET: ${{ matrix.target }}
          FORMATS: ${{ matrix.formats }}
        run: cargo packager --release --target "$TARGET" --formats "$FORMATS"

      - name: Build binary for target (Windows)
        if: matrix.kind == 'windows'
        env:
          TARGET: ${{ matrix.target }}
        shell: pwsh
        run: cargo build --release --target $env:TARGET

      - name: Build and package (Windows)
        if: matrix.kind == 'windows'
        env:
          TARGET: ${{ matrix.target }}
          FORMATS: ${{ matrix.formats }}
        shell: pwsh
        run: cargo packager --release --target $env:TARGET --formats $env:FORMATS

      - name: Collect package artifacts (macOS/Linux)
        if: matrix.kind != 'windows'
        id: collect_unix
        env:
          TARGET: ${{ matrix.target }}
          KIND: ${{ matrix.kind }}
          PRODUCT_NAME: Proteus Player
        run: |
          set -euo pipefail
          mkdir -p dist

          while IFS= read -r artifact; do
            file_name="$(basename "$artifact")"

            case "$file_name" in
              control.tar.gz|data.tar.gz|debian-binary|PKGBUILD|*.PKGBUILD)
                continue
                ;;
            esac

            output_name="$file_name"
            if [ "$KIND" = "linux" ]; then
              output_name="${output_name/#proteus-player/$PRODUCT_NAME}"
            fi

            cp "$artifact" "dist/$output_name"
          done < <(find target -type f \( \
              -name '*.dmg' -o \
              -name '*.deb' -o \
              -name '*.AppImage' -o \
              -name '*.appimage' -o \
              -name 'proteus-player*.tar.gz' -o \
              -name '*.pkg.tar*' \
            \))

          if [ "$KIND" = "macos" ]; then
            while IFS= read -r app_bundle; do
              bundle_name="$(basename "$app_bundle")"
              archive_name="dist/${bundle_name}.zip"
              ditto -c -k --sequesterRsrc --keepParent "$app_bundle" "$archive_name"
            done < <(find target -type d -name '*.app')
          fi

          if [ -z "$(ls -A dist)" ]; then
            echo "No packaged artifacts were produced." >&2
            exit 1
          fi

          echo "dist_dir=dist" >> "$GITHUB_OUTPUT"

      - name: Collect package artifacts (Windows)
        if: matrix.kind == 'windows'
        id: collect_windows
        shell: pwsh
        env:
          PRODUCT_NAME: Proteus Player
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          Get-ChildItem -Path target/release -File |
            Where-Object {
              ($_.Extension -eq ".msi") -or
              ($_.Name -like "*-setup.exe")
            } |
            ForEach-Object {
              $renamed = $_.Name -replace '^proteus-player', $env:PRODUCT_NAME
              $destination = Join-Path "dist" $renamed
              Copy-Item -LiteralPath $_.FullName -Destination $destination -Force
            }

          if (-not (Get-ChildItem -Path dist -File | Select-Object -First 1)) {
            throw "No packaged artifacts were produced."
          }

          "dist_dir=dist" >> $env:GITHUB_OUTPUT

      - name: Upload artifact (macOS/Linux)
        if: matrix.kind != 'windows'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.prepare-release.outputs.version }}
          DIST_DIR: ${{ steps.collect_unix.outputs.dist_dir }}
        run: |
          TAG="${RELEASE_TAG_PREFIX}${VERSION}"
          gh release upload "${TAG}" "${DIST_DIR}"/* --clobber

      - name: Upload artifact (Windows)
        if: matrix.kind == 'windows'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.prepare-release.outputs.version }}
          DIST_DIR: ${{ steps.collect_windows.outputs.dist_dir }}
        shell: pwsh
        run: |
          $tag = "$env:RELEASE_TAG_PREFIX$env:VERSION"
          Get-ChildItem -Path $env:DIST_DIR -File | ForEach-Object {
            gh release upload $tag $_.FullName --clobber
          }

  publish-downloads-manifest:
    needs: [prepare-release, publish-iced]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build downloads.json
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.prepare-release.outputs.version }}
        run: |
          TAG="${RELEASE_TAG_PREFIX}${VERSION}"

          gh api "repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}" > release.json

          jq \
            --arg version "${VERSION}" \
            --arg tag "${TAG}" \
            --arg generated_at "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
            '{
              version: $version,
              tag: $tag,
              release_url: .html_url,
              generated_at: $generated_at,
              assets: [
                .assets[]
                | select(.name != "downloads.json")
                | {
                    name,
                    size,
                    content_type,
                    download_url: .browser_download_url
                  }
              ]
            }' release.json > downloads.json

          gh release upload "${TAG}" downloads.json --clobber
